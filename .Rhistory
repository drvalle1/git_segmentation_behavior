max.time=max(dat$time1)
max.SL=max(dat$SL, na.rm = T)
max.TA=max(dat$TA, na.rm = T)
#starting values
breakpt=mean(dat$time1)
#to store results
res.brks=vector("list", ngibbs)
res.LML=matrix(NA,1,(ngibbs+1))
res.nbrks=matrix(NA,1,(ngibbs+1))
store.param=matrix(NA,ngibbs,2)
for (i in 1:ngibbs){
vals=samp.move(breakpt=breakpt,max.time=max.time,dat=dat,
alpha=alpha,max.SL=max.SL,max.TA=max.TA)
breakpt=vals[[1]]
#store results
res.brks[[i]]<- breakpt
store.param[i,]=c(length(breakpt), vals[[2]])
}
View(res.brks)
View(res.nbrks)
tmp=store.param[,1]
res.nbrks[1,]=c(uni.id,tmp)
View(res.nbrks)
View(res.brks)
behav.gibbs.sampler=function(dat,ngibbs) {
set.seed(1)
uni.id=unique(dat$id)
#priors
alpha=1
#useful stuff
max.time=max(dat$time1)
max.SL=max(dat$SL, na.rm = T)
max.TA=max(dat$TA, na.rm = T)
#starting values
breakpt=mean(dat$time1)
#to store results
res.brks=vector("list", ngibbs)
res.LML=matrix(NA,1,(ngibbs+1))
res.nbrks=matrix(NA,1,(ngibbs+1))
store.param=matrix(NA,ngibbs,2)
for (i in 1:ngibbs){
vals=samp.move(breakpt=breakpt,max.time=max.time,dat=dat,
alpha=alpha,max.SL=max.SL,max.TA=max.TA)
breakpt=vals[[1]]
#store results
res.brks[[i]]<- breakpt
store.param[i,]=c(length(breakpt), vals[[2]])
}
tmp=store.param[,1]
res.nbrks[1,]=c(uni.id,tmp)
colnames(res.nbrks)<- c('id', paste0("Iter_",1:ngibbs))
tmp=store.param[,2]
res.LML[1,]=c(uni.id,tmp)
colnames(res.LML)<- c('id', paste0("Iter_",1:ngibbs))
list(breakpt=res.brks, nbrks=res.nbrks, LML=res.LML)
}
mod<- future_map(data, function(x) behav.gibbs.sampler(dat = x, ngibbs = ngibbs), .progress = TRUE)
mod<- future_map(behav.list, function(x) behav.gibbs.sampler(dat = x, ngibbs = ngibbs), .progress = TRUE)
View(mod)
brkpts<- map_dfr(mod, 1)
brkpts<- map(mod, 1)
View(brkpts)
#----------------------------------------------------
behavior_segment=function(data, ngibbs) {
tic()  #start timer
mod<- future_map(data, function(x) behav.gibbs.sampler(dat = x, ngibbs = ngibbs), .progress = TRUE)
toc()  #provide elapsed time
brkpts<- map(mod, 1)  #create list of all sets breakpoints by ID
nbrks<- map_dfr(mod, 2) %>% t() %>% data.frame()  #create DF of number of breakpoints by ID
names(nbrks)<- c('id', paste0("Iter_",1:ngibbs))
LML<- map_dfr(mod, 3) %>% t() %>% data.frame()  #create DF of LML by ID
names(LML)<- c('id', paste0("Iter_",1:ngibbs))
list(brkpts = brkpts, nbrks = nbrks, LML = LML)
}
test<- behavior_segment(behav.list, ngibbs)
#---------------------------------------------
getMAP=function(dat,nburn) {  #select MAP value that is beyond burn-in phase
if (length(max(dat$loglikel)) > 1) {
stop("> 1 MAP value; inspect likelihood vector")
} else if (which.max(dat$loglikel) < nburn) {
MAP<- dat$loglikel %>% order(decreasing = T) %>% subset(. > nburn) %>% first()
} else {
MAP<- which.max(dat$loglikel)
}
return(MAP)
}
#---------------------------------------------
getMAP=function(dat,nburn) {  #select MAP value that is beyond burn-in phase
if (length(max(dat$loglikel)) > 1) {
stop("> 1 MAP value; inspect likelihood vector")
} else if (which.max(dat$loglikel) < nburn) {
MAP<- dat$loglikel %>% order(decreasing = T) %>% subset(. > nburn) %>% first()
} else {
MAP<- which.max(dat$loglikel)
}
return(MAP)
}
#---------------------------------------------
getMAP=function(dat,nburn) {  #select MAP value that is beyond burn-in phase
if (length(max(dat$loglikel)) > 1) {
stop("> 1 MAP value; inspect likelihood vector")
} else if (which.max(dat$loglikel) < nburn) {
MAP<- dat$loglikel %>% order(decreasing = T) %>% subset(. > nburn) %>% first()
} else {
MAP<- which.max(dat$loglikel)
}
return(MAP)
}
View(dat.res)
dat<- dat.res$LML
View(dat)
summary(dat)
max(dat)
max(dat[,-1])
testdat[1,]
test<- dat[1,]
#---------------------------------------------
getMAP=function(dat,nburn) {  #select MAP value that is beyond burn-in phase
if (which.max(dat) < nburn) {
MAP<- dat %>% order(decreasing = T) %>% subset(. > nburn) %>% first()
} else {
MAP<- which.max(dat)
}
return(MAP)
}
#---------------------------------------------
getMAP=function(dat,nburn) {  #select MAP value that is beyond burn-in phase
if (which.max(dat[,-1]) < nburn) {
MAP<- dat[,-1] %>% order(decreasing = T) %>% subset(. > nburn) %>% first()
} else {
MAP<- which.max(dat[,-1])
}
return(MAP)
}
getMAP(test,30)
which.max(test[,-1])
##Determine MAP for selecting breakpoints
MAP<- apply(dat.res$LML, 1, getMAP(nburn = 100))
##Determine MAP for selecting breakpoints
MAP<- apply(dat.res$LML, 1, getMAP(., nburn = 100))
##Determine MAP for selecting breakpoints
MAP<- apply(dat.res$LML, 1, function(x) getMAP(dat = x, nburn = 100))
#---------------------------------------------
getMAP=function(dat,nburn) {  #select MAP value that is beyond burn-in phase
if (which.max(dat[,-1]) < nburn) {
MAP<- dat[-1] %>% order(decreasing = T) %>% subset(. > nburn) %>% first()
} else {
MAP<- which.max(dat[,-1])
}
return(MAP)
}
##Determine MAP for selecting breakpoints
MAP<- apply(dat.res$LML, 1, function(x) getMAP(dat = x, nburn = 100))
#---------------------------------------------
getMAP=function(dat,nburn) {  #select MAP value that is beyond burn-in phase
if (which.max(dat[-1]) < nburn) {
MAP<- dat[-1] %>% order(decreasing = T) %>% subset(. > nburn) %>% first()
} else {
MAP<- which.max(dat[-1])
}
return(MAP)
}
##Determine MAP for selecting breakpoints
MAP<- apply(dat.res$LML, 1, function(x) getMAP(dat = x, nburn = 100))
MAP
View(dat.res)
##Determine MAP for selecting breakpoints
MAP<- apply(dat.res$LML, 1, function(x) getMAP(dat = x, nburn = 500))
MAP
View(dat.res)
View(brkpts)
View(mod)
length(brkpts)
brkpts[[1]]
brkpts[[1]][[1]]
brkpts[[1]][[500]]
i=1
ind<- MAP[i]
ind
i=2
ind<- MAP[i]
ind
ind/10
ind/20
ind/100
brkpts[[1]][[ind/100]]
tmp<- matrix(NA, length(brkpts), brk.cols)
#---------------------------------------------
getBreakpts=function(dat,MAP,brk.cols) {  #extract breakpoints of MAP per ID
tmp<- matrix(NA, length(dat), brk.cols)
for(i in 1:length(dat)) {
ind<- MAP[i]
tmp[i,]<- dat[[i]][[ind]]
}
}
library(tidyverse)
library(tictoc)
library(furrr)
library(viridis)
source('gibbs functions2.R')
source('helper functions.R')
source('gibbs sampler2.R')
dat<- read.csv("Snail Kite Gridded Data_larger.csv", header = T, sep = ",")
#remove IDs w < 200 obs; won't run well
dat<- dat %>% group_by(id) %>% filter(n() > 200) %>% ungroup()
dat<- read.csv("Snail Kite Gridded Data_larger.csv", header = T, sep = ",")
#remove IDs w < 200 obs; won't run well
dat<- dat %>% group_by(id) %>% filter(n() > 200) %>% ungroup()
dat.list<- df.to.list(dat=dat)
behav.list<- behav.prep(dat=dat, tstep = 3600)  #add move params and filter by 3600 s interval
ngibbs = 1000
## Run Gibbs sampler
plan(multisession)  #run all MCMC chains in parallel
dat.res<- behavior_segment(dat = behav.list, ngibbs = ngibbs)
View(dat.res)
## Traceplots
#type is either 'nbrks' or 'LML' for y-axis label
identity<- names(behav.list)
##Determine MAP for selecting breakpoints
MAP<- apply(dat.res$LML, 1, function(x) getMAP(dat = x, nburn = 500))
MAP
traceplot(data = dat.res$LML, type = "LML", identity = identity)
brkpts<- getBreakpts(dat = dat.res$brkpts, MAP = MAP, brk.cols = 99)  #brk.cols is max matrix cols
brkpts<- getBreakpts(dat = dat.res$brkpts, MAP = MAP, brk.cols = 150)  #brk.cols is max matrix cols
dat<- dat.res$brkpts
brk.cols=99
tmp<- matrix(NA, length(dat), brk.cols)
i=1
ind<- MAP[i]
tmp[i,]<- dat[[i]][[ind]]
dat[[i]][[ind]]
View(tmp)
1:length(dat[[i]][[ind]])
tmp[i,1:length(dat[[i]][[ind]])]<- dat[[i]][[ind]]
View(tmp)
#---------------------------------------------
getBreakpts=function(dat,MAP,brk.cols) {  #extract breakpoints of MAP per ID
tmp<- matrix(NA, length(dat), brk.cols)
for(i in 1:length(dat)) {
ind<- MAP[i]
tmp[i,1:length(dat[[i]][[ind]])]<- dat[[i]][[ind]]
}
}
tmp<- cbind(id = identity, tmp)
View(tmp)
#---------------------------------------------
getBreakpts=function(dat,MAP,brk.cols) {  #extract breakpoints of MAP per ID
tmp<- matrix(NA, length(dat), brk.cols)
for(i in 1:length(dat)) {
ind<- MAP[i]
tmp[i,1:length(dat[[i]][[ind]])]<- dat[[i]][[ind]]
}
tmp<- cbind(id = identity, tmp)
tmp
}
brkpts<- getBreakpts(dat = dat.res$brkpts, MAP = MAP, brk.cols = 99)  #brk.cols is max matrix cols
View(brkpts)
#---------------------------------------------
getBreakpts=function(dat,MAP,brk.cols) {  #extract breakpoints of MAP per ID
tmp<- matrix(NA, length(dat), brk.cols)
for(i in 1:length(dat)) {
ind<- MAP[i]
tmp[i,1:length(dat[[i]][[ind]])]<- round(dat[[i]][[ind]], 2)
}
tmp<- cbind(id = identity, tmp) %>% data.frame()
tmp
}
brkpts<- getBreakpts(dat = dat.res$brkpts, MAP = MAP, brk.cols = 99)  #brk.cols is max matrix cols
View(brkpts)
#---------------------------------------------
getBreakpts=function(dat,MAP,brk.cols) {  #extract breakpoints of MAP per ID
tmp<- matrix(NA, length(dat), brk.cols)
for(i in 1:length(dat)) {
ind<- MAP[i]
tmp[i,1:length(dat[[i]][[ind]])]<- round(dat[[i]][[ind]], 2)
}
tmp<- cbind(id = identity, tmp) %>% data.frame()
names(tmp)<- c('id', paste0("Brk",1:brk.cols))
tmp
}
brkpts<- getBreakpts(dat = dat.res$brkpts, MAP = MAP, brk.cols = 99)  #brk.cols is max matrix cols
#---------------------------------------------
getBreakpts=function(dat,MAP,brk.cols) {  #extract breakpoints of MAP per ID
tmp<- matrix(NA, length(dat), brk.cols)
for(i in 1:length(dat)) {
ind<- MAP[i]
tmp[i,1:length(dat[[i]][[ind]])]<- round(dat[[i]][[ind]], 2)
}
tmp<- cbind(id = identity, tmp) %>% data.frame()
names(tmp)<- c('id', paste0("Brk_",1:brk.cols))
tmp
}
brkpts<- getBreakpts(dat = dat.res$brkpts, MAP = MAP, brk.cols = 99)  #brk.cols is max matrix cols
View(behav.list)
data<- behav.list[[1]]
ind=which(unique(data$id) == brkpts$id)
ind
breakpt<- brkpts[ind,-1] %>% discard(is.na) %>% t() %>% data.frame()
View(breakpt)
View(brkpts)
names(breakpt)<- "breaks"
source('helper functions.R')
## Heatmaps
heatmap(data = behav.list, brkpts = brkpts, dat.res = dat.res, type = "behav")
behav.heat<- behav.seg.image(data)
SL<- data.frame(behav.heat$SL)
names(SL)<- 1:6
SL<- SL %>% gather(key, value) %>% mutate(time=rep(data$time1, times=6),
behav=rep("SL", nrow(data)*6))
# SL$key<- as.numeric(SL$key)
TA<- data.frame(behav.heat$TA)
names(TA)<- 1:8
TA<- TA %>% gather(key, value) %>% mutate(time=rep(data$time1, times=8),
behav=rep("TA", nrow(data)*8))
# TA$key<- as.numeric(TA$key)
behav.heat_long<- rbind(SL,TA)
ggplot(behav.heat_long, aes(x=time, y=key, fill=value)) +
geom_tile() +
facet_wrap(~behav, scales = 'free', nrow = 2) +
scale_fill_viridis_c(guide=F)
ggplot(behav.heat_long, aes(x=time, y=key, fill=value)) +
geom_tile() +
facet_wrap(~behav, scales = 'free', nrow = 2) +
scale_fill_viridis_c(guide=F)
print(
ggplot(behav.heat_long, aes(x=time, y=key, fill=value)) +
geom_tile() +
facet_wrap(~behav, scales = 'free', nrow = 2) +
scale_fill_viridis_c(guide=F) +
scale_y_discrete(expand = c(0,0)) +
scale_x_continuous(expand = c(0,0)) +
geom_vline(data = breakpt, aes(xintercept = breaks), color = viridis(n=9)[7],
size = 0.4) +
labs(x = "Observations", y = "Bin", title = paste("ID", unique(data$id))) +
theme_bw() +
theme(axis.title = element_text(size = 18), axis.text = element_text(size = 12),
strip.text = element_text(size = 12, face = 'bold'),
title = element_text(size = 20))
)
str(brkpts)
#---------------------------------------------
getBreakpts=function(dat,MAP,brk.cols) {  #extract breakpoints of MAP per ID
tmp<- matrix(NA, length(dat), brk.cols)
for(i in 1:length(dat)) {
ind<- MAP[i]
tmp[i,1:length(dat[[i]][[ind]])]<- round(dat[[i]][[ind]], 2)
}
tmp<- cbind(id = identity, tmp) %>% data.frame()
names(tmp)<- c('id', paste0("Brk_",1:brk.cols))
tmp<- mutate_all(tmp, function(x) as.numeric(as.character(x)))
tmp
}
brkpts<- getBreakpts(dat = dat.res$brkpts, MAP = MAP, brk.cols = 99)  #brk.cols is max matrix cols
str(brkpts)
ind=which(unique(data$id) == brkpts$id)
breakpt<- brkpts[ind,-1] %>% discard(is.na) %>% t() %>% data.frame()
names(breakpt)<- "breaks"
print(
ggplot(behav.heat_long, aes(x=time, y=key, fill=value)) +
geom_tile() +
facet_wrap(~behav, scales = 'free', nrow = 2) +
scale_fill_viridis_c(guide=F) +
scale_y_discrete(expand = c(0,0)) +
scale_x_continuous(expand = c(0,0)) +
geom_vline(data = breakpt, aes(xintercept = breaks), color = viridis(n=9)[7],
size = 0.4) +
labs(x = "Observations", y = "Bin", title = paste("ID", unique(data$id))) +
theme_bw() +
theme(axis.title = element_text(size = 18), axis.text = element_text(size = 12),
strip.text = element_text(size = 12, face = 'bold'),
title = element_text(size = 20))
)
## Heatmaps
heatmap(data = behav.list, brkpts = brkpts, dat.res = dat.res, type = "behav")
dat_out<- map(behav.list, assign.time.seg) %>% map_dfr(`[`)  #assign time seg and make as DF
dat<- data
ind=which(unique(dat$id) == brkpts$id)
breakpt<- brkpts[ind,-1] %>% discard(is.na)
str(breakpt)
breakpt<- brkpts[ind,-1] %>% discard(is.na) %>% as.numeric(.[1,])
breakpt<- brkpts[ind,-1] %>% discard(is.na) %>% as.numeric(.[1,])
str(breakpt)
#---------------------------------------
assign.time.seg=function(dat){
tmp=which(unique(dat$id) == brkpts$id)
breakpt<- brkpts[tmp,-1] %>% discard(is.na) %>% as.numeric(.[1,])
breakpt1=c(0,breakpt,Inf)
n=length(breakpt1)
res=matrix(0,nrow(dat),1)
for (i in 2:n){
ind=which(breakpt1[i-1]<dat$time1 & dat$time1<breakpt1[i])
res[ind,]=i-1
}
dat$tseg<- as.vector(res)
dat
}
#---------------------------------------
assign.time.seg=function(dat){
tmp=which(unique(dat$id) == brkpts$id)
breakpt<- brkpts[tmp,-1] %>% discard(is.na) %>% as.numeric(.[1,])
breakpt1=c(0,breakpt,Inf)
n=length(breakpt1)
res=matrix(0,nrow(dat),1)
for (i in 2:n){
ind=which(breakpt1[i-1]<dat$time1 & dat$time1<breakpt1[i])
res[ind,]=i-1
}
dat$tseg<- as.vector(res)
dat
}
dat_out<- map(behav.list, assign.time.seg) %>% map_dfr(`[`)  #assign time seg and make as DF
View(dat_out)
library(tidyverse)
library(tictoc)
library(furrr)
library(viridis)
source('gibbs functions2.R')
source('helper functions.R')
source('gibbs sampler2.R')
dat<- read.csv("Snail Kite Gridded Data_larger.csv", header = T, sep = ",")
#remove IDs w < 200 obs; won't run well
dat<- dat %>% group_by(id) %>% filter(n() > 200) %>% ungroup()
dat.list<- df.to.list(dat=dat)
behav.list<- behav.prep(dat=dat, tstep = 3600)  #add move params and filter by 3600 s interval
ngibbs = 20000
## Run Gibbs sampler
plan(multisession)  #run all MCMC chains in parallel
dat.res<- behavior_segment(dat = behav.list, ngibbs = ngibbs)
warnings()
View(dat.res)
2125/60
## Traceplots
#type is either 'nbrks' or 'LML' for y-axis label
identity<- names(behav.list)
traceplot(data = dat.res$nbrks, type = "nbrks", identity = identity)
traceplot(data = dat.res$LML, type = "LML", identity = identity)
##Determine MAP for selecting breakpoints
MAP<- apply(dat.res$LML, 1, function(x) getMAP(dat = x, nburn = 500))
MAP
brkpts<- getBreakpts(dat = dat.res$brkpts, MAP = MAP, brk.cols = 99)  #brk.cols is max matrix cols
## Heatmaps
heatmap(data = behav.list, brkpts = brkpts, dat.res = dat.res, type = "behav")
dat_out<- map(behav.list, assign.time.seg) %>% map_dfr(`[`)  #assign time seg and make as DF
View(dat_out)
setwd("~/Documents/Snail Kite Project/Data/R Scripts/git_LDA_behavior")
write.csv(dat_out, "Snail Kite Gridded Data_larger_behav.csv", row.names = F)
library(tidyverse)
library(tictoc)
library(furrr)
library(viridis)
source('gibbs functions2.R')
source('helper functions.R')
source('gibbs sampler2.R')
dat<- read.csv("Snail Kite Gridded Data_larger.csv", header = T, sep = ",")
View(dat)
#remove IDs w < 200 obs; won't run well
dat<- dat %>% group_by(id) %>% filter(n() > 200) %>% ungroup()
dat.list<- df.to.list(dat=dat)
behav.list<- behav.prep(dat=dat, tstep = 3600)  #add move params and filter by 3600 s interval
ngibbs = 20000
## Run Gibbs sampler
plan(multisession)  #run all MCMC chains in parallel
dat.res<- behavior_segment(dat = behav.list, ngibbs = ngibbs)
2182.109/60
## Traceplots
#type is either 'nbrks' or 'LML' for y-axis label
identity<- names(behav.list)
traceplot(data = dat.res$nbrks, type = "nbrks", identity = identity)
traceplot(data = dat.res$LML, type = "LML", identity = identity)
##Determine MAP for selecting breakpoints
MAP<- apply(dat.res$LML, 1, function(x) getMAP(dat = x, nburn = 500))
MAP
brkpts<- getBreakpts(dat = dat.res$brkpts, MAP = MAP, brk.cols = 99)  #brk.cols is max matrix cols
View(brkpts)
## Heatmaps
heatmap(data = behav.list, brkpts = brkpts, dat.res = dat.res, type = "behav")
dat<- behav.list[[1]]
tmp=which(unique(dat$id) == brkpts$id)
breakpt<- brkpts[tmp,-1] %>% discard(is.na) %>% as.numeric(.[1,])
breakpt
breakpt1=c(0,breakpt,Inf)
breakpt1
n=length(breakpt1)
res=matrix(NA,nrow(dat),1)
i=2
ind=which(breakpt1[i-1]<dat$time1 & dat$time1<breakpt1[i])
res[ind,]=i-1
View(res)
for (i in 2:n){
ind=which(breakpt1[i-1]<dat$time1 & dat$time1<breakpt1[i])
res[ind,]=i-1
}
unique(res)
res[is.na(res),]
which(is.na(res))
res=matrix(NA,nrow(dat),1)
for (i in 2:n){
ind=which(breakpt1[i-1]<=dat$time1 & dat$time1<breakpt1[i])
res[ind,]=i-1
}
which(is.na(res))
unique(res)
dat_out<- map(behav.list, assign.time.seg) %>% map_dfr(`[`)  #assign time seg and make as DF
View(dat_out)
dat_out[is.na(dat_out$tseg),]
which(is.na(dat_out$tseg))
source('helper functions.R')
dat_out<- map(behav.list, assign.time.seg) %>% map_dfr(`[`)  #assign time seg and make as DF
dat_out[is.na(dat_out$tseg),]
which(is.na(dat_out$tseg))
setwd("~/Documents/Snail Kite Project/Data/R Scripts/git_LDA_behavior")
write.csv(dat_out, "Snail Kite Gridded Data_larger_behav.csv", row.names = F)
