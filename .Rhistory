abline(v=cumsum(partition))
obs1=data.frame(loc.id=obs)
obs1$time1=1:nobs
setwd('U:\\GIT_models\\git_segmentation_model')
write.csv(obs1,'fake data.csv',row.names=F)
head(obs1)
obs
rm(list=ls(all=TRUE))
set.seed(1)
setwd('U:\\GIT_models\\git_segmentation_model')
source('gibbs functions.R')
dat=read.csv('fake data.csv',as.is=T)
#priors
alpha=0.01
#useful stuff
max.time=max(dat$time1)
nloc=ncol(dat)-1
#starting values
breakpt=mean(dat$time1)
ngibbs=10000
head(dat)
breakpt.old=breakpt
p=length(breakpt)
rand1=runif(1)
p0=1
new.brk=runif(1,min=0,max=max.time)
if (p == 1) {
#birth
if (rand1 < 1/2){
breakpt.new=sort(c(breakpt.old,new.brk))
p0=2/3 #death prob 2 -> 1 is (1/3) and birth prob 1 -> 2 is 1/2.
}
#swap
if (rand1 > 1/2) breakpt.new=new.brk
}
if (p > 1) {
#birth
if (rand1 < 1/3) {
breakpt.new=sort(c(breakpt.old,new.brk))
}
#death
if (rand1 > 1/3 & rand1 < 2/3) {
ind=sample(1:length(breakpt.old),size=1)
breakpt.new=breakpt.old[-ind]
if (p==2) p0=3/2 #birth prob from 1 -> 2 is 1/2 and death prob from 2 -> 1 is 1/3
}
#swap
if (rand1 > 2/3) {
ind=sample(1:length(breakpt.old),size=1)
breakpt.new=sort(c(breakpt.old[-ind],new.brk))
}
}
stats.old=get.summary.stats(breakpt=breakpt.old,dat=dat,nloc=nloc)
stats.new=get.summary.stats(breakpt=breakpt.new,dat=dat,nloc=nloc)
breakpt=breakpt.old
breakpt1=c(0,breakpt,Inf)
n=length(breakpt1)
res=matrix(0,n-1,nloc)
for (i in 2:n){
ind=which(breakpt1[i-1]<dat$time1 & dat$time1<breakpt1[i])
tmp=dat[ind,'loc.id']
tmp1=table(tmp)
ind=as.numeric(names(tmp1))
res[i-1,ind]=tmp1
}
i
ind
head(dat)
tmp1
ind
breakpt1=c(0,breakpt,Inf)
n=length(breakpt1)
res=matrix(0,n-1,nloc)
for (i in 2:n){
ind=which(breakpt1[i-1]<dat$time1 & dat$time1<breakpt1[i])
tmp=dat[ind,'loc.id']
tmp1=table(tmp)
ind=as.numeric(names(tmp1))
res[i-1,ind]=tmp1
}
nloc
rm(list=ls(all=TRUE))
set.seed(1)
setwd('U:\\GIT_models\\git_segmentation_model')
source('gibbs functions.R')
dat=read.csv('fake data.csv',as.is=T)
#priors
alpha=0.01
#useful stuff
max.time=max(dat$time1)
nloc=max(dat$loc.id)
#starting values
breakpt=mean(dat$time1)
ngibbs=10000
for (i in 1:ngibbs){
print(i)
breakpt=samp.move(breakpt=breakpt,max.time=max.time,dat=dat,
alpha=alpha,nloc=nloc)
}
length(breakpt)
abline(v=breakpt/nrow(dat),lty=3,col='green')
length(breakpt)
abline(v=breakpt,lty=3,col='green')
rm(list=ls(all=TRUE))
library('MCMCpack')
set.seed(1)
nobs=1000
nseg=10
tmp=runif(nseg)
prob=tmp/sum(tmp); prob
partition=rmultinom(1,size=nobs,prob=prob)
seg.index=rep(1:nseg,times=partition)
nloc=100
#step length
prob.SL=matrix(c(0.6,0.2,0.1,0.1,
0.2,0.1,0.5,0.2,
0.1,0.1,0.1,0.7),3,4,byrow=T)
apply(prob.SL,1,sum)
rm(list=ls(all=TRUE))
library('MCMCpack')
set.seed(1)
nobs=1000
nseg=10
tmp=runif(nseg)
prob=tmp/sum(tmp); prob
partition=rmultinom(1,size=nobs,prob=prob)
seg.index=rep(1:nseg,times=partition)
nloc=100
#step length
prob.SL=matrix(c(0.6,0.2,0.1,0.1,
0.2,0.1,0.5,0.2,
0.1,0.1,0.1,0.7),3,4,byrow=T)
apply(prob.SL,1,sum)
#turning angle
prob.TA=matrix(c(0.6,0.2,0.1,0.1,
0.3,0.3,0.2,0.2,
0.2,0.1,0.5,0.2,
0.1,0.1,0.1,0.7),4,4,byrow=T)
apply(prob.TA,1,sum)
rm(list=ls(all=TRUE))
library('MCMCpack')
set.seed(1)
nobs=1000
nseg=10
tmp=runif(nseg)
prob=tmp/sum(tmp); prob
partition=rmultinom(1,size=nobs,prob=prob)
seg.index=rep(1:nseg,times=partition)
nloc=100
#step length (multinomial with 4 categories)
prob.SL=matrix(c(0.6,0.2,0.1,0.1,
0.2,0.1,0.5,0.2,
0.1,0.1,0.1,0.7),3,4,byrow=T)
apply(prob.SL,1,sum)
prob.SL1=prob.SL[sample(3,size=nseg,replace=T),]
dim(prob.SL1)
prob.SL1
rm(list=ls(all=TRUE))
library('MCMCpack')
set.seed(1)
nobs=1000
nseg=10
tmp=runif(nseg)
prob=tmp/sum(tmp); prob
partition=rmultinom(1,size=nobs,prob=prob)
seg.index=rep(1:nseg,times=partition)
nloc=100
#step length (multinomial with 4 categories)
prob.SL=matrix(c(0.6,0.2,0.1,0.1,
0.2,0.1,0.5,0.2,
0.1,0.1,0.1,0.7),3,4,byrow=T)
#apply(prob.SL,1,sum) #basic checking
ind=sample(3,size=nseg,replace=T)
prob.SL1=prob.SL[ind,]
#turning angle  (multinomial with 4 categories)
prob.TA=matrix(c(0.6,0.2,0.1,0.1,
0.3,0.3,0.2,0.2,
0.2,0.1,0.5,0.2,
0.1,0.1,0.1,0.7),4,4,byrow=T)
#apply(prob.TA,1,sum)  #basic checking
ind=sample(4,size=nseg,replace=T)
prob.TA1=prob.TA[ind,]
dim(prob.TA1)
prob.TAA=c(0.5,0.9)
ind=sample(2,size=nseg,replace=T)
prob.TAA=prob.TAA[ind]
prob.TAA
rm(list=ls(all=TRUE))
library('MCMCpack')
set.seed(1)
nobs=1000
nseg=10
tmp=runif(nseg)
prob=tmp/sum(tmp); prob
partition=rmultinom(1,size=nobs,prob=prob)
seg.index=rep(1:nseg,times=partition)
nloc=100
#step length (multinomial with 4 categories)
prob.SL=matrix(c(0.6,0.2,0.1,0.1,
0.2,0.1,0.5,0.2,
0.1,0.1,0.1,0.7),3,4,byrow=T)
#apply(prob.SL,1,sum) #basic checking
ind=sample(3,size=nseg,replace=T)
prob.SL1=prob.SL[ind,]
#turning angle  (multinomial with 4 categories)
prob.TA=matrix(c(0.6,0.2,0.1,0.1,
0.3,0.3,0.2,0.2,
0.2,0.1,0.5,0.2,
0.1,0.1,0.1,0.7),4,4,byrow=T)
#apply(prob.TA,1,sum)  #basic checking
ind=sample(4,size=nseg,replace=T)
prob.TA1=prob.TA[ind,]
#turning angle autocorrelation (bernoulli)
prob.TAA=c(0.5,0.9)
ind=sample(2,size=nseg,replace=T)
prob.TAA1=prob.TAA[ind]
#generate observations
obs=matrix(NA,nobs,3)
for (i in 1:nobs){
tmp.SL=rmultinom(1,size=1,prob=prob.SL1[seg.index[i],])
tmp.TA=rmultinom(1,size=1,prob=prob.TA1[seg.index[i],])
tmp.TAA=rbinom(1,size=1,prob=prob.TAA1[seg.index[i]])
obs[i,]=c(which(tmp.SL==1),which(tmp.TA==1),tmp.TAA)
}
head(obs)
rm(list=ls(all=TRUE))
library('MCMCpack')
set.seed(1)
nobs=1000
nseg=10
tmp=runif(nseg)
prob=tmp/sum(tmp); prob
partition=rmultinom(1,size=nobs,prob=prob)
seg.index=rep(1:nseg,times=partition)
nloc=100
#step length (multinomial with 4 categories)
prob.SL=matrix(c(0.6,0.2,0.1,0.1,
0.2,0.1,0.5,0.2,
0.1,0.1,0.1,0.7),3,4,byrow=T)
#apply(prob.SL,1,sum) #basic checking
ind=sample(3,size=nseg,replace=T)
prob.SL1=prob.SL[ind,]
#turning angle  (multinomial with 4 categories)
prob.TA=matrix(c(0.6,0.2,0.1,0.1,
0.3,0.3,0.2,0.2,
0.2,0.1,0.5,0.2,
0.1,0.1,0.1,0.7),4,4,byrow=T)
#apply(prob.TA,1,sum)  #basic checking
ind=sample(4,size=nseg,replace=T)
prob.TA1=prob.TA[ind,]
#turning angle autocorrelation (bernoulli)
prob.TAA=c(0.5,0.9)
ind=sample(2,size=nseg,replace=T)
prob.TAA1=prob.TAA[ind]
#generate observations
obs=matrix(NA,nobs,3)
for (i in 1:nobs){
tmp.SL=rmultinom(1,size=1,prob=prob.SL1[seg.index[i],])
tmp.TA=rmultinom(1,size=1,prob=prob.TA1[seg.index[i],])
tmp.TAA=rbinom(1,size=1,prob=prob.TAA1[seg.index[i]])
obs[i,]=c(which(tmp.SL==1),which(tmp.TA==1),tmp.TAA)
}
#plot these data
par(mfrow=c(3,1))
for (i in 1:3){
plot(obs[,i])
abline(v=cumsum(partition))
}
obs1=as.data.frame(obs)
obs1$time1=1:nobs
head(obs1)
obs1=data.frame(SL=obs[,1],TA=obs[,2],TAA=obs[,3])
obs1$time1=1:nobs
head(obs1)
setwd('U:\\GIT_models\\git_segmentation_behavior')
write.csv(obs1,'fake data.csv',row.names=F)
rm(list=ls(all=TRUE))
set.seed(1)
setwd('U:\\GIT_models\\git_segmentation_behavior')
source('gibbs functions.R')
dat=read.csv('fake data.csv',as.is=T)
rm(list=ls(all=TRUE))
set.seed(1)
setwd('U:\\GIT_models\\git_segmentation_behavior')
source('gibbs functions.R')
dat=read.csv('fake data.csv',as.is=T)
#priors
alpha=0.01
bern.a=bern.b=1
#useful stuff
max.time=max(dat$time1)
head(dat)
rm(list=ls(all=TRUE))
set.seed(1)
setwd('U:\\GIT_models\\git_segmentation_behavior')
source('gibbs functions.R')
dat=read.csv('fake data.csv',as.is=T)
#priors
alpha=0.01
bern.a=bern.b=1
#useful stuff
max.time=max(dat$time1)
max.SL=max(dat$SL)
max.TA=max(dat$TA)
#starting values
breakpt=mean(dat$time1)
ngibbs=10000
head(dat)
rm(list=ls(all=TRUE))
set.seed(1)
setwd('U:\\GIT_models\\git_segmentation_behavior')
source('gibbs functions.R')
dat=read.csv('fake data.csv',as.is=T)
#priors
alpha=0.01
bern.a=bern.b=1
#useful stuff
max.time=max(dat$time1)
max.SL=max(dat$SL)
max.TA=max(dat$TA)
#starting values
breakpt=mean(dat$time1)
ngibbs=10000
rm(list=ls(all=TRUE))
set.seed(1)
setwd('U:\\GIT_models\\git_segmentation_behavior')
source('gibbs functions.R')
dat=read.csv('fake data.csv',as.is=T)
#priors
alpha=0.01
bern.a=bern.b=1
#useful stuff
max.time=max(dat$time1)
max.SL=max(dat$SL)
max.TA=max(dat$TA)
#starting values
breakpt=mean(dat$time1)
ngibbs=10000
breakpt=samp.move(breakpt=breakpt,max.time=max.time,dat=dat,
alpha=alpha,bern.a=bern.a,bern.b=bern.b,
max.SL=max.SL,max.TA=max.TA)
rm(list=ls(all=TRUE))
set.seed(1)
setwd('U:\\GIT_models\\git_segmentation_behavior')
source('gibbs functions.R')
dat=read.csv('fake data.csv',as.is=T)
#priors
alpha=0.01
bern.a=bern.b=1
#useful stuff
max.time=max(dat$time1)
max.SL=max(dat$SL)
max.TA=max(dat$TA)
#starting values
breakpt=mean(dat$time1)
ngibbs=10000
breakpt.old=breakpt
p=length(breakpt)
rand1=runif(1)
p0=1
new.brk=runif(1,min=0,max=max.time)
if (p == 1) {
#birth
if (rand1 < 1/2){
breakpt.new=sort(c(breakpt.old,new.brk))
p0=2/3 #death prob 2 -> 1 is (1/3) and birth prob 1 -> 2 is 1/2.
}
#swap
if (rand1 > 1/2) breakpt.new=new.brk
}
if (p > 1) {
#birth
if (rand1 < 1/3) {
breakpt.new=sort(c(breakpt.old,new.brk))
}
#death
if (rand1 > 1/3 & rand1 < 2/3) {
ind=sample(1:length(breakpt.old),size=1)
breakpt.new=breakpt.old[-ind]
if (p==2) p0=3/2 #birth prob from 1 -> 2 is 1/2 and death prob from 2 -> 1 is 1/3
}
#swap
if (rand1 > 2/3) {
ind=sample(1:length(breakpt.old),size=1)
breakpt.new=sort(c(breakpt.old[-ind],new.brk))
}
}
#get sufficient statistics
stats.old=get.summary.stats(breakpt=breakpt.old,dat=dat,max.SL=max.SL,max.TA=max.TA)
str(stats.old)
colnames(stats.old$res.TAA)
stats.new=get.summary.stats(breakpt=breakpt.new,dat=dat,max.SL=max.SL,max.TA=max.TA)
pold=log.marg.likel(alpha=alpha,summary.stats=stats.old,bern.a=bern.a,bern.b=bern.b,max.SL=max.SL,max.TA=max.TA)
summary.stats=stats.old
lnum=rowSums(lgamma(alpha+summary.stats$res.SL))
lden=lgamma(max.SL*alpha+rowSums(summary.stats$res.SL))
p2=sum(lnum)-sum(lden)
p1=nrow(summary.stats$res.SL)*(lgamma(max.SL*alpha)-max.SL*lgamma(alpha))
p.SL=p1+p2
#get ratio for TA
lnum=rowSums(lgamma(alpha+summary.stats$res.TA))
lden=lgamma(max.TA*alpha+rowSums(summary.stats$res.TA))
p2=sum(lnum)-sum(lden)
p1=nrow(summary.stats$res.TA)*(lgamma(max.TA*alpha)-max.TA*lgamma(alpha))
p.TA=p1+p2
lnum=rowSums(lgamma(bern.a+summary.stats$res.TAA[,'n1'])+lgamma(bern.b+summary.stats$res.TAA[,'n0']))
lden=lgamma(rowSums(summary.stats$res.TAA)+bern.a+bern.b)
p2=sum(lnum)-sum(lden)
p1=nrow(summary.stats$res.TAA)*(lgamma(bern.a+bern.b)-lgamma(bern.a)-lgamma(bern.b))
p.TAA=p1+p2
p.SL+p.TA+p.TAA
stats.old=get.summary.stats(breakpt=breakpt.old,dat=dat,max.SL=max.SL,max.TA=max.TA)
stats.new=get.summary.stats(breakpt=breakpt.new,dat=dat,max.SL=max.SL,max.TA=max.TA)
pold=log.marg.likel(alpha=alpha,summary.stats=stats.old,bern.a=bern.a,bern.b=bern.b,max.SL=max.SL,max.TA=max.TA)
dim(stats.old$res.TAA)
rm(list=ls(all=TRUE))
set.seed(1)
setwd('U:\\GIT_models\\git_segmentation_behavior')
source('gibbs functions.R')
dat=read.csv('fake data.csv',as.is=T)
#priors
alpha=0.01
bern.a=bern.b=1
#useful stuff
max.time=max(dat$time1)
max.SL=max(dat$SL)
max.TA=max(dat$TA)
#starting values
breakpt=mean(dat$time1)
ngibbs=10000
breakpt.old=breakpt
p=length(breakpt)
rand1=runif(1)
p0=1
new.brk=runif(1,min=0,max=max.time)
if (p == 1) {
#birth
if (rand1 < 1/2){
breakpt.new=sort(c(breakpt.old,new.brk))
p0=2/3 #death prob 2 -> 1 is (1/3) and birth prob 1 -> 2 is 1/2.
}
#swap
if (rand1 > 1/2) breakpt.new=new.brk
}
if (p > 1) {
#birth
if (rand1 < 1/3) {
breakpt.new=sort(c(breakpt.old,new.brk))
}
#death
if (rand1 > 1/3 & rand1 < 2/3) {
ind=sample(1:length(breakpt.old),size=1)
breakpt.new=breakpt.old[-ind]
if (p==2) p0=3/2 #birth prob from 1 -> 2 is 1/2 and death prob from 2 -> 1 is 1/3
}
#swap
if (rand1 > 2/3) {
ind=sample(1:length(breakpt.old),size=1)
breakpt.new=sort(c(breakpt.old[-ind],new.brk))
}
}
#get sufficient statistics
stats.old=get.summary.stats(breakpt=breakpt.old,dat=dat,max.SL=max.SL,max.TA=max.TA)
stats.new=get.summary.stats(breakpt=breakpt.new,dat=dat,max.SL=max.SL,max.TA=max.TA)
log.marg.likel(alpha=alpha,summary.stats=stats.old,bern.a=bern.a,bern.b=bern.b,max.SL=max.SL,max.TA=max.TA)
summary.stats=stats.old
lnum=rowSums(lgamma(alpha+summary.stats$res.SL))
lden=lgamma(max.SL*alpha+rowSums(summary.stats$res.SL))
p2=sum(lnum)-sum(lden)
p1=nrow(summary.stats$res.SL)*(lgamma(max.SL*alpha)-max.SL*lgamma(alpha))
p.SL=p1+p2
#get ratio for TA
lnum=rowSums(lgamma(alpha+summary.stats$res.TA))
lden=lgamma(max.TA*alpha+rowSums(summary.stats$res.TA))
p2=sum(lnum)-sum(lden)
p1=nrow(summary.stats$res.TA)*(lgamma(max.TA*alpha)-max.TA*lgamma(alpha))
p.TA=p1+p2
#get ratio for TAA
lnum=rowSums(lgamma(bern.a+summary.stats$res.TAA[,'n1'])+lgamma(bern.b+summary.stats$res.TAA[,'n0']))
dim(summary.stats$res.TAA)
colnames(summary.stats$res.TAA)
bern.a
summary.stats$res.TAA[,'n1']
lnum=lgamma(bern.a+summary.stats$res.TAA[,'n1'])+lgamma(bern.b+summary.stats$res.TAA[,'n0'])
lden=lgamma(rowSums(summary.stats$res.TAA)+bern.a+bern.b)
p2=sum(lnum)-sum(lden)
p1=nrow(summary.stats$res.TAA)*(lgamma(bern.a+bern.b)-lgamma(bern.a)-lgamma(bern.b))
p.TAA=p1+p2
p.SL+p.TA+p.TAA
rm(list=ls(all=TRUE))
set.seed(1)
setwd('U:\\GIT_models\\git_segmentation_behavior')
source('gibbs functions.R')
dat=read.csv('fake data.csv',as.is=T)
#priors
alpha=0.01
bern.a=bern.b=1
#useful stuff
max.time=max(dat$time1)
max.SL=max(dat$SL)
max.TA=max(dat$TA)
#starting values
breakpt=mean(dat$time1)
ngibbs=10000
for (i in 1:ngibbs){
print(i)
breakpt=samp.move(breakpt=breakpt,max.time=max.time,dat=dat,
alpha=alpha,bern.a=bern.a,bern.b=bern.b,
max.SL=max.SL,max.TA=max.TA)
}
length(breakpt)
abline(v=breakpt,lty=3,col='green')
